package com.google.ginkage.qdmat;

import javax.swing.*;
import javax.swing.event.TreeExpansionEvent;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.event.TreeWillExpandListener;
import javax.swing.plaf.ComponentUI;
import javax.swing.plaf.PanelUI;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;
import java.util.*;

public class HeapContents implements TreeWillExpandListener, TreeSelectionListener, MouseListener {
    private JPanel contentPanel;
    private JTabbedPane tabbedPane;
    private JPanel objectTab;
    private JPanel componentTab;
    private JTree componentTree;
    private JPanel bitmapTab;
    private JTree bitmapTree;
    private JTree objectTree;
    private JLabel dataLabel;
    private JLabel bitmapLabel;

    private Set<ObjectNode> mGraph;
    private SortedSet<ObjectNode> mNodes;
    private Map<ObjectNode, BufferedImage> mBitmaps;
    private Set<ComponentNode> mComponents;
    private int mFindBitmap;
    private TreeNode mFoundNode;

    DefaultMutableTreeNode mObjectRoot;

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        createUIComponents();
        contentPanel = new JPanel();
        contentPanel.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane = new JTabbedPane();
        contentPanel.add(tabbedPane, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, null, new Dimension(1280, 720), null, 0, false));
        objectTab = new JPanel();
        objectTab.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane.addTab("Objects", objectTab);
        final JScrollPane scrollPane1 = new JScrollPane();
        objectTab.add(scrollPane1, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        scrollPane1.setViewportView(objectTree);
        final JPanel panel1 = new JPanel();
        panel1.setLayout(new BorderLayout(0, 0));
        objectTab.add(panel1, new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        dataLabel = new JLabel();
        dataLabel.setText("");
        panel1.add(dataLabel, BorderLayout.CENTER);
        componentTab = new JPanel();
        componentTab.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane.addTab("Components", componentTab);
        final JScrollPane scrollPane2 = new JScrollPane();
        componentTab.add(scrollPane2, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        scrollPane2.setViewportView(componentTree);
        bitmapTab = new JPanel();
        bitmapTab.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));
        tabbedPane.addTab("Bitmaps", bitmapTab);
        final JScrollPane scrollPane3 = new JScrollPane();
        bitmapTab.add(scrollPane3, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));
        scrollPane3.setViewportView(bitmapTree);
        final JPanel panel2 = new JPanel();
        panel2.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(1, 1, new Insets(0, 0, 0, 0), -1, -1));
        bitmapTab.add(panel2, new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));
        bitmapLabel = new JLabel();
        bitmapLabel.setText("");
        panel2.add(bitmapLabel, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER, com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return contentPanel;
    }

    private class ObjectTreeNode extends DefaultMutableTreeNode {
        public ObjectNode mNode;

        ObjectTreeNode(ObjectNode node) {
            super(node.getType() +
                    ", weighed_size=" + Math.round(node.size) +
                    ", retain_size=" + node.retSize + " (" + node.unique.size() + " objects)");
            mNode = node;
            add(new DefaultMutableTreeNode("dummy"));
        }

        ObjectTreeNode(ObjectNode node, String name) {
            super(name + " [" + Math.round(node.size) + " bytes]");
            mNode = node;
            add(new DefaultMutableTreeNode("dummy"));
        }
    }

    private class RetainTreeNode extends DefaultMutableTreeNode {
        public ObjectNode mNode;
        public RetainTreeNode mParent;
        public int mRetCount;
        public int mRetSize;
        public String mType;
        public String mPath;

        RetainTreeNode(ObjectNode node, String type, String path) {
            super(type + " " + path + " [" + Math.round(node.size) + " bytes]");
            mNode = node;
            mParent = null;
            mRetCount = 0;
            mRetSize = node.selfSize;
            mType = type;
            mPath = path;
        }

        public void setName() {
            setUserObject(mType + " " + mPath /*+ " #" + mNode.object.getObjectId()*/ +
                    (mRetCount > 0 ? " (" + mRetCount + " objects)" : "") + " [" + mRetSize + " bytes]");
        }
    }

    private class BitmapTreeNode extends DefaultMutableTreeNode {
        public ObjectNode mNode;

        BitmapTreeNode(ObjectNode node) {
            super(node.object.getObjectId() +
                    " (" + mBitmaps.get(node).getWidth() + " x " + mBitmaps.get(node).getHeight()
                    + ") [" + Math.round(node.size) + " bytes]");
            mNode = node;
        }
    }

    private class BitmapRetNode extends DefaultMutableTreeNode {
        public ObjectNode mNode;
        public int mObjectId;
        String mType;
        String mPath;

        BitmapRetNode(ObjectNode node, String type, String path, int objectId) {
            super(type + " . " + path);
            mNode = node;
            mObjectId = objectId;
            mType = type;
            mPath = path;
        }
    }

    private class MyRenderer extends DefaultTreeCellRenderer {

        JLabel typeLabel = new JLabel("");
        JLabel pathLabel = new JLabel("");
        JLabel retCountLabel = new JLabel("");
        JLabel retSizeLabel = new JLabel("");
        JPanel renderer = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));

        public MyRenderer() {
            typeLabel.setFont(super.getFont());
            pathLabel.setFont(super.getFont());
            retCountLabel.setFont(super.getFont());
            retSizeLabel.setFont(super.getFont());

            renderer.add(typeLabel);
            renderer.add(pathLabel);
            renderer.add(retCountLabel);
            renderer.add(retSizeLabel);
        }

        public Component getTreeCellRendererComponent(
                JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {

            super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);
            if (value == null) {
                return this;
            }

            if (value instanceof RetainTreeNode) {
                RetainTreeNode node = (RetainTreeNode) value;
                typeLabel.setText(node.mType);
                pathLabel.setText(node.mPath.length() > 0 ? " " + node.mPath : "");
                pathLabel.setForeground(new Color(0, 0, 191));
                retCountLabel.setText((node.mRetCount > 0 ? " (" + node.mRetCount + " objects)" : ""));
                retCountLabel.setForeground(new Color(191, 0, 0));
                retSizeLabel.setText(" [" + node.mRetSize + " bytes]");
                retSizeLabel.setForeground(new Color(0, 127, 127));

                typeLabel.setIcon(super.getIcon());
                renderer.setBackground(sel ?
                        super.getBackgroundSelectionColor() : super.getBackgroundNonSelectionColor());

                return renderer;
            } else if (value instanceof ObjectTreeNode) {
                ObjectTreeNode treeNode = (ObjectTreeNode) value;
                ObjectNode node = treeNode.mNode;
                typeLabel.setText(node.getType());
                pathLabel.setText(" {" + Math.round(node.size) + " bytes}");
                pathLabel.setForeground(Color.GRAY);
                retCountLabel.setText((node.unique.size() > 0 ? " (" + node.unique.size() + " objects)" : ""));
                retCountLabel.setForeground(new Color(191, 0, 0));
                retSizeLabel.setText(" [" + node.retSize + " bytes]");
                retSizeLabel.setForeground(new Color(0, 127, 127));
                typeLabel.setIcon(super.getIcon());
                renderer.setBackground(sel ?
                        super.getBackgroundSelectionColor() : super.getBackgroundNonSelectionColor());

                return renderer;
            } else if (value instanceof BitmapRetNode) {
                BitmapRetNode node = (BitmapRetNode) value;
                typeLabel.setText(node.mType + " . ");
                pathLabel.setText(node.mPath);
                pathLabel.setForeground(new Color(0, 0, 191));
                retCountLabel.setText("");
                retSizeLabel.setText("");
                typeLabel.setIcon(super.getIcon());
                renderer.setBackground(sel ?
                        super.getBackgroundSelectionColor() : super.getBackgroundNonSelectionColor());

                return renderer;
            }

            return this;
        }

    }

    HeapContents(Set<ObjectNode> graph, SortedSet<ObjectNode> nodes, Map<ObjectNode, BufferedImage> bitmaps) {
        mGraph = graph;
        mNodes = nodes;
        mBitmaps = bitmaps;
        mFindBitmap = -1;
        mFoundNode = null;
        $$$setupUI$$$();
    }

    public static void run(Set<ObjectNode> graph, SortedSet<ObjectNode> nodes, Map<ObjectNode, BufferedImage> bitmaps) {
        JFrame frame = new JFrame("HeapContents");
        HeapContents gui = new HeapContents(graph, nodes, bitmaps);
        frame.setContentPane(gui.contentPanel);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }

    private void createUIComponents() {
        MyRenderer renderer = new MyRenderer();

        mObjectRoot = new DefaultMutableTreeNode("Objects");

        for (ObjectNode node : mNodes) {
            ObjectTreeNode newNode = new ObjectTreeNode(node);
            mObjectRoot.add(newNode);
        }

        objectTree = new JTree(mObjectRoot);
        objectTree.addTreeWillExpandListener(this);
        objectTree.addTreeSelectionListener(this);
        objectTree.setCellRenderer(renderer);

        DefaultMutableTreeNode componentRoot = new DefaultMutableTreeNode("Components");

        final Map<String, Double> typeSize = new HashMap<>();
        final Map<String, Integer> retSize = new HashMap<>();
        int totalSize = 0;
        for (ObjectNode node : mNodes) {
            String name = node.getType();
            if (!typeSize.containsKey(name)) {
                typeSize.put(name, node.size);
            } else {
                typeSize.put(name, typeSize.get(name) + node.size);
            }
            if (!retSize.containsKey(name)) {
                retSize.put(name, node.retSize);
            } else {
                retSize.put(name, retSize.get(name) + node.retSize);
            }
            totalSize += node.size;
        }

        SortedSet<String> types = new TreeSet<>(new Comparator<String>() {
            public int compare(String a, String b) {
                return ((typeSize.get(a) < typeSize.get(b)) ? 1 : -1);
            }
        });
        types.addAll(typeSize.keySet());

        for (String type : types) {
            double size = typeSize.get(type);
            componentRoot.add(new DefaultMutableTreeNode(String.format("%s [%d bytes] (%.2f%%) / %d\n",
                    type, Math.round(size), size * 100 / totalSize, retSize.get(type))));
        }

        componentTree = new JTree(componentRoot);

        Comparator<ObjectNode> objectComparator = new Comparator<ObjectNode>() {
            public int compare(ObjectNode a, ObjectNode b) {
                return (a.size < b.size ? 1 : -1);
            }
        };

        DefaultMutableTreeNode bitmapRoot = new DefaultMutableTreeNode("Bitmaps");
        SortedSet<ObjectNode> sortedBitmaps = new TreeSet<>(objectComparator);
        sortedBitmaps.addAll(mBitmaps.keySet());

        for (ObjectNode bitmap : sortedBitmaps) {
            BitmapTreeNode node = new BitmapTreeNode(bitmap);
            bitmapRoot.add(node);
            for (ObjectNode ref : node.mNode.retainedBy) {
                node.add(new BitmapRetNode(ref,
                        ref.getType(), ref.retains.get(bitmap), node.mNode.object.getObjectId()));
            }
        }

        bitmapTree = new JTree(bitmapRoot);
        bitmapTree.addTreeSelectionListener(this);
        bitmapTree.addMouseListener(this);
        bitmapTree.setCellRenderer(renderer);
    }

    public void unfoldRetains(ObjectNode node, RetainTreeNode retRoot, Set<ObjectNode> retSet, int findId) {
        Comparator<RetainTreeNode> treeComparator = new Comparator<RetainTreeNode>() {
            public int compare(RetainTreeNode a, RetainTreeNode b) {
                return (a.mRetSize < b.mRetSize ? 1 :
                        (a.mRetSize > b.mRetSize ? -1 : a.mPath.compareTo(b.mPath)));
            }
        };

        Map<String, RetainTreeNode> retPaths = new TreeMap<>();
        for (ObjectNode ref : retSet) {
            String retPath = node.retains.get(ref);
            retPaths.put(retPath, new RetainTreeNode(ref,
                    ref.getType(), retPath));
        }

        for (String retPath : retPaths.keySet()) {
            RetainTreeNode retNode = retPaths.get(retPath);
            boolean found = false;
            int lastDot = Math.max(retPath.lastIndexOf('.'), retPath.lastIndexOf('['));
            while (lastDot >= 0 && !found) {
                String part = retPath.substring(0, lastDot);
                lastDot = Math.max(part.lastIndexOf('.'), part.lastIndexOf('['));
                RetainTreeNode parent = retPaths.get(part);
                if (parent != null) {
                    retNode.mParent = parent;
                    found = true;
                }
            }
            if (!found) {
                retNode.mParent = retRoot;
            }

            if (retNode.mNode.object.getObjectId() == findId) {
                mFoundNode = retNode;
            }
        }

        for (String retPath : retPaths.keySet()) {
            RetainTreeNode ref = retPaths.get(retPath);
            RetainTreeNode parent = ref.mParent;
            while (parent != null) {
                parent.mRetSize += ref.mRetSize;
                parent.mRetCount++;
                parent = parent.mParent;
            }
        }

        SortedSet<RetainTreeNode> sortedRets = new TreeSet<>(treeComparator);
        sortedRets.addAll(retPaths.values());
        for (RetainTreeNode ref : sortedRets) {
            ref.mParent.add(ref);
        }

        for (RetainTreeNode ref : sortedRets) {
            ref.setName();
        }
        retRoot.setName();
    }

    public void createSubNodes(ObjectTreeNode treeNode) {
        ObjectNode node = treeNode.mNode;

        Comparator<ObjectNode> objectComparator = new Comparator<ObjectNode>() {
            public int compare(ObjectNode a, ObjectNode b) {
                return (a.size < b.size ? 1 : -1);
            }
        };

        DefaultMutableTreeNode inRefs = new DefaultMutableTreeNode(
                "Incoming references (" + node.inRefs.size() + " objects)");
        SortedSet<ObjectNode> sortedInRefs = new TreeSet<>(objectComparator);
        sortedInRefs.addAll(node.inRefs);
        for (ObjectNode ref : sortedInRefs) {
            inRefs.add(new ObjectTreeNode(ref,
                    ref.getType() + " . " + ref.outRefs.get(node)));
        }

        DefaultMutableTreeNode outRefs = new DefaultMutableTreeNode(
                "Outgoing references (" + node.outRefs.size() + " objects)");
        SortedSet<ObjectNode> sortedOutRefs = new TreeSet<>(objectComparator);
        sortedOutRefs.addAll(node.outRefs.keySet());
        for (ObjectNode ref : sortedOutRefs) {
            outRefs.add(new ObjectTreeNode(ref,
                    ref.getType() + " " + node.outRefs.get(ref)));
        }

        RetainTreeNode unique = new RetainTreeNode(node, "Unique retains", "");
        unfoldRetains(node, unique, node.unique, -1);

        RetainTreeNode retains = new RetainTreeNode(node, "All retains", "");
        unfoldRetains(node, retains, node.retains.keySet(), mFindBitmap);

        treeNode.removeAllChildren();
        treeNode.add(inRefs);
        treeNode.add(outRefs);
        treeNode.add(unique);
        treeNode.add(retains);
    }

    @Override
    public void treeWillExpand(TreeExpansionEvent treeExpansionEvent) throws ExpandVetoException {
        TreePath path = treeExpansionEvent.getPath();
        Object last = path.getLastPathComponent();
        if (last instanceof ObjectTreeNode) {
            ObjectTreeNode treeNode = (ObjectTreeNode) last;
            createSubNodes(treeNode);
        }
    }

    @Override
    public void treeWillCollapse(TreeExpansionEvent treeExpansionEvent) throws ExpandVetoException {
        TreePath path = treeExpansionEvent.getPath();
        Object last = path.getLastPathComponent();
        if (last instanceof ObjectTreeNode) {
            ObjectTreeNode node = (ObjectTreeNode) last;
            node.removeAllChildren();
            node.add(new DefaultMutableTreeNode("dummy"));
        }
    }

    @Override
    public void valueChanged(TreeSelectionEvent treeSelectionEvent) {
        TreePath path = treeSelectionEvent.getPath();
        Object last = path.getLastPathComponent();
        if (last instanceof RetainTreeNode) {
            RetainTreeNode treeNode = (RetainTreeNode) last;
            ObjectNode node = treeNode.mNode;
            if (node.getType().equals("android.graphics.Bitmap")) {
                dataLabel.setText("");
                dataLabel.setIcon(new ImageIcon(mBitmaps.get(node)));
                return;
            } else {
                String name = node.object.getClassSpecificName();
                if (name != null) {
                    dataLabel.setText(name);
                    dataLabel.setIcon(null);
                    return;
                }
            }
        } else if (last instanceof BitmapTreeNode) {
            BitmapTreeNode bitmap = (BitmapTreeNode) last;
            bitmapLabel.setIcon(new ImageIcon(mBitmaps.get(bitmap.mNode)));
            return;
        }
        dataLabel.setText("");
        dataLabel.setIcon(null);
    }

    @Override
    public void mouseClicked(MouseEvent mouseEvent) {
        Object src = mouseEvent.getSource();
        if ((mouseEvent.getClickCount() == 2) && (src instanceof JTree)) {
            JTree tree = (JTree) src;
            TreePath path = tree.getSelectionPath();
            if (path == null) {
                return;
            }
            Object last = path.getLastPathComponent();
            if (last instanceof BitmapRetNode) {
                BitmapRetNode ret = (BitmapRetNode) last;
                int id = ret.mNode.object.getObjectId();
                Enumeration e = mObjectRoot.children();
                while (e.hasMoreElements()) {
                    ObjectTreeNode node = ObjectTreeNode.class.cast(e.nextElement());
                    if (node != null && node.mNode.object.getObjectId() == id) {
                        TreeNode[] nodes = ((DefaultTreeModel) tree.getModel()).getPathToRoot(node);
                        TreePath tpath = new TreePath(nodes);
                        tabbedPane.setSelectedIndex(0);
                        objectTree.setSelectionPath(tpath);
                        objectTree.scrollPathToVisible(tpath);

                        mFindBitmap = ret.mObjectId;
                        objectTree.expandPath(tpath);
                        if (mFoundNode != null) {
                            nodes = ((DefaultTreeModel) tree.getModel()).getPathToRoot(mFoundNode);
                            tpath = new TreePath(nodes);
                            objectTree.setSelectionPath(tpath);
                            objectTree.scrollPathToVisible(tpath);
                        }
                        mFindBitmap = -1;
                        mFoundNode = null;
                    }
                }
            }
        }
    }

    @Override
    public void mousePressed(MouseEvent mouseEvent) {
    }

    @Override
    public void mouseReleased(MouseEvent mouseEvent) {
    }

    @Override
    public void mouseEntered(MouseEvent mouseEvent) {
    }

    @Override
    public void mouseExited(MouseEvent mouseEvent) {
    }
}
